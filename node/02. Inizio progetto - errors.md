Dopo aver creato la cartella `src` e i file `index.ts` e `app.ts` iniziamo a popolarli, per prima cosa installiamo i seguenti pacchetti: `dotenv`, `express`, `mongoose`, `morgan`, `body-parser`

Per iniziare la parte di gestione errori bisogna installare `express` e i suoi `tipi`

``` bash
npm install express
npm install --save-dev @types/express
```

Adesso partiamo creando gli errori

``` bash
mkdir src/errors
touch src/errors/internal-server-error.ts
touch src/errors/not-found.ts
touch src/errors/dotenv.ts
touch src/errors/custom.ts
touch src/errors/unouthorized.ts
touch src/errors/validation.ts
touch src/errors/user-exist.ts
touch src/errors/index.ts
```


Adesso che abbiamo una buona base, iniziamo con il capire come funziona tutta la parte della gestione errori, iniziamo con il creare il classicissimo errore 404 (not found)

``` ts
import { Request, Response, NextFunction } from "express";

export class NotFoundError extends Error {
  constructor(entity?: string) {
    super(`Entity ${entity} not found`);
    this.name = "NotFoundError";
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
}

export const notFoundHandler = (err: Error, req: Request, res: Response, next: NextFunction) => {
  if (err instanceof NotFoundError) {
    res.status(404).json({
      error: err.name,
      message: err.message
    });
  } else {
    next(err);
  }
};
```

Dopo aver creato questo file bisogna inserirlo nel file `index.ts` (quello degli errori che abbiamo appena creato)

``` ts
import { notFoundHandler } from "./not-found";

export const errorHandlers = [
    notFoundHandler
]
```

##### Capiamo il funzionamento dei file appena creati

Adesso capiamo come funziona e soprattutto perché funziona. Nel file `not-found.ts` abbiamo esportato 2 elementi: una `constante` e una `classe`, la classe è quella che andrai a richiamare dovunque ti serva richiamare questo specifico errore, ad esempio così

``` ts
throw new NotFoundError(entity);
```

Cosa fa `super()`? La parola chiave `super()` in TypeScript (e JavaScript) viene usata per **chiamare il costruttore della classe padre**, ovvero la classe da cui stai estendendo.

##### Effetto:
- Imposta il messaggio dell'errore (`err.message`)
- Permette al motore JavaScript/TypeScript di gestire lo stack trace correttamente
- Ti consente di accedere a metodi/attributi di `Error`

##### Quindi questa riga:

``` ts
super(`Entity ${entity} not found`);
```

Equivale a scrivere la riga qui sotto ma all'interno della tua sottoclasse personalizzata. :

``` ts
const error = new Error(`Entity ${entity} not found`);
```

Quando estendi `Error`, è buona pratica anche aggiungere:

``` ts
Object.setPrototypeOf(this, NotFoundError.prototype);
```

Per garantire che `instanceof` funzioni correttamente, specialmente in ambienti JavaScript transpiled (come quando usi `tsc`). questo garantisce che funzioni correttamente quando chiami l'instanza ad esempio quando in un controller controlli di che tipo è l'errore, se entra nel blocco else `next()` si occupa di scorrere tutti gli errori dentro `index.ts` che poi collegheremo in `app.ts` e controlla tutte le istanze fino a trovare quella corretta, quindi in `errorHandlers` gli errori vanno messi a livello di importanza dal più restrittivo al più generico. il più generico di solito è `internal server error` con status code `500` che indica che l'errore generato non è stato gestito da nessun `middleware`. In quel caso bisogna trovare dove viene generato l'errore e tipizzarlo.

``` ts
if(err instanceof NotFoundError) {/*Fai qualcosa*/} 
```

Adesso che abbiamo capito a cosa serve la classe vediamo a cosa serve la costante `notFoundHandler`, semplicemente si occupa di catturare tutti gli errori di tipo `NotFoundError` e impostare l'errore con il `name` e il `message` che abbiamo nel `constructor`, ricordiamo che `message` non lo dichiariamo direttamente ma lo fa `super()` dietro le quinte. Adesso che abbiamo capito come funziona tutta la logica di gestione degli errori (`middleware`) creiamo tutti gli errori che ci servono.

#### Errori di base

##### `Unouthorized error`

``` ts
import { Request, Response, NextFunction } from "express";

export class UnauthorizedError extends Error {
  constructor(message = "User not authorized") {
    super(message);
    this.name = "UnauthorizedError";
    Object.setPrototypeOf(this, UnauthorizedError.prototype);
  }
}

export const unauthorizedHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  if (err instanceof UnauthorizedError) {
    res.status(401).json({
      error: err.name,
      message: err.message
    });
  } else {
    next(err);
  }
};
```

##### `Dotenv error`

``` ts
import { Request, Response, NextFunction } from "express";

export class DotEnvError extends Error {
  constructor(entity?: string) {
    super(`Entity ${entity} not found in dotenv`);
    this.name = "DotEnvError";
    Object.setPrototypeOf(this, DotEnvError.prototype);
  }
}

export const dotenvHandler = (err: Error, req: Request, res: Response, next: NextFunction) => {
  if (err instanceof DotEnvError) {
    res.status(404).json({
      error: err.name,
      message: err.message
    });
  } else {
    next(err);
  }
};
```


``` bash
npm install dotenv express mongoose morgan body-parser cors reflect-metadata
npm install --save-dev @types/express @types/cors @types/morgan @types/body-parser
```