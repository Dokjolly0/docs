---
layout: default
title: Avvio del server
---

<link rel="stylesheet" href="/assets/css/custom.css">

Pacchetti necessari per questa sezione, ricordati anche di controllare il file `.env` e controllare che ci siano tutti i valori [qui](node/00.file_env.md)
``` bash
npm install reflect-metadata cors morgan
npm install --save-dev nodemon eslint eslint-plugin-import @types/cors @types/morgan
```

Creazione delle routes in `routes.ts`

``` bash
touch ./src/api/routes.ts
```

Adesso popoliamo il file `index.ts` e capiamone la logica

### `index.ts`

``` ts
import "reflect-metadata";
import mongoose from "mongoose";

import app from "./app";
import { requireEnvVars } from "./utils/dotenv";

const [MONGO_URI, DB_NAME, PORT, ENVIRONMENT] = requireEnvVars([
  "MONGO_URI",
  "DB_NAME",
  "PORT",
  "ENVIRONMENT"
]);

// Attiva il debug solo in sviluppo
if (process.env.ENVIRONMENT !== "production") {
  mongoose.set("debug", true);
}
mongoose
  .connect(`${MONGO_URI}/${DB_NAME}`)
  .then((_) => {
    app.listen(PORT, () => {
      console.log(`Server started on port ${PORT}`);
    });
  })
  .catch((err) => {
    console.error(err);
  });
```

L'importazione di `"reflect-metadata"` serve per **abilitare la riflessione a runtime in TypeScript**, ed Ã¨ **essenziale** se utilizzi **decoratori**, come quelli usati con:

- `class-validator`
- `class-transformer`
- `type-graphql`
- `routing-controllers`
- e altre librerie che usano **metadata reflection**

### ğŸ§  Cos'Ã¨ la "riflessione"?

La **riflessione** permette di:

- leggere **metadati** su classi, proprietÃ  e metodi,
- sapere il tipo di un parametro o una proprietÃ  a **runtime**,
- permettere alle librerie di fare introspezione e generare comportamento dinamico.

### ğŸ”§ PerchÃ© ti serve in questo progetto?

Nel tuo caso stai usando:

- `class-validator` â†’ per validare DTO con decoratori come `@IsEmail()`, `@IsNumber()`, ecc.
- `class-transformer` â†’ per trasformare oggetti da `plain object` a classi

Entrambe **dipendono** da `reflect-metadata` per sapere:

- qual Ã¨ il tipo di ogni proprietÃ  (`number`, `string`, `Date`, ecc.)
- cosa Ã¨ stato decorato con cosa

#### â— Senza `reflect-metadata`?

Se lo dimentichi:

- i decoratori sembrano funzionare ma **non validano niente** (nessun errore anche se `@IsEmail()` fallisce)
- alcuni errori silenziosi e comportamenti inaspettati

### âœ… In sintesi

|**Serve per**|**PerchÃ© Ã¨ importante**|
|---|---|
|Abilitare decoratori TypeScript|Decoratori lavorano con `class-validator`, ecc.|
|Leggere i tipi delle proprietÃ  a runtime|class-transformer e altri si basano su metadati|
|Fondamentale per DTO, validazioni, riflessioni|Decoratori senza questo non funzionano|

### Creazione del server con mongoose

Adesso che abbiamo capito l'importanza di `reflect-metadata` vediamo nel dettaglio come funziona la creazione del server con `mongoose`

``` ts
mongoose.set("debug", true);
```

âœ… **Cosa fa**:  
Abilita il **debug mode** di Mongoose. Questo significa che tutte le query eseguite da Mongoose verranno stampate sulla console. Ãˆ utile per capire cosa sta facendo il codice "dietro le quinte", soprattutto durante lo sviluppo. Quindi se vuoi deployare l'app ricordati di settare `ENVIRONMENT` a production nel file `.env`

``` ts
mongoose.connect(`${MONGO_URI}/${DB_NAME}`)
```

âœ… **Cosa fa**:  
Tenta di connettersi a un database MongoDB.

- `MONGO_URI`: Ã¨ una variabile che contiene lâ€™URL base del server MongoDB (es. `mongodb://localhost:27017`)
- `DB_NAME`: Ã¨ il nome del database (es. `myapp`)
- Quindi `\${MONGO_URI}/${DB_NAME}` sarÃ  qualcosa tipo`mongodb://localhost:27017/myapp`

``` ts
  .then((_) => {
    PORT;
    app.listen(PORT, () => {
      console.log(`Server started on port ${PORT}`);
    });
  })
```

âœ… **Cosa fa**:

- `.then(...)` viene eseguito **dopo che la connessione a MongoDB ha avuto successo**.
- `app.listen(PORT, ...)`: Avvia il server Express e lo mette in ascolto sulla porta `PORT`.
- Una volta avviato, stampa in console che il server Ã¨ attivo.

#### â“ Ma perchÃ© si usa `_`?

- Si usa `_` **per convenzione** quando **non si ha bisogno** del valore.
- Ãˆ un modo per dire: _"So che c'Ã¨ un valore, ma non mi interessa usarlo."_  
    (Simile al "placeholder" `_` in altri linguaggi come Python o Elixir.)

#### âŒ Posso rimuovere `_`?

SÃ¬, se non usi il parametro, puoi anche ometterlo completamente:

``` ts
.catch((err) => {
    console.error(err);
  });
```

Se invece la connessione fallisce il programma entra nel `.catch(...)` che al momento stampa solo un messaggio di errore

### `app.ts`

``` ts
import express from "express";
import cors from "cors";
import morgan from "morgan";
import apiRouter from "./api/routes";
import { errorHandlers } from "./errors";
import "./utils/auth/auth-handlers";

const app = express();

app.use(cors());
app.use(morgan("tiny"));
app.use(express.json()); // Prima di express 4.16 -> app.use(bodyParser.json());
app.use("/api", apiRouter);
app.use(errorHandlers);

export default app;
```

Adesso vediamo come funziona l'app:

``` ts
const app = express();
```

Qui crei l'app che poi verrÃ  usata nel file index per creare il server

``` ts
app.use(cors());
app.use(morgan("tiny"));
app.use(express.json()); // Prima di express 4.16 -> app.use(bodyParser.json());
app.use("/api", apiRouter);
app.use(errorHandlers);
```

### ğŸ”¹ `app.use(cors());`

âœ… **Cos'Ã¨:**  
Abilita **CORS** (Cross-Origin Resource Sharing).

âœ… **A cosa serve:**  
Permette che il tuo server accetti **richieste da domini diversi** (es: se il frontend Ã¨ su `http://localhost:3000` e il backend su `http://localhost:5000`).

âš ï¸ **Senza CORS**, il browser bloccherebbe queste richieste per motivi di sicurezza.

#### ğŸ› ï¸ Settaggi di cors

âœ… 1. **Permettere solo un dominio specifico (es. frontend)**

``` ts
app.use(cors({
  origin: 'http://localhost:5000'
}));
```

âœ… 2. **Permettere piÃ¹ domini**

``` ts
const allowedOrigins = ['http://localhost:3000', 'https://myapp.com'];

app.use(cors({
  origin: function(origin, callback) {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  }
}));
```

âœ… 3. **Permettere invio di cookie (credentials)**

``` ts
app.use(cors({
  origin: 'http://localhost:3000',
  credentials: true
}));
```

âœ… 4. **Permettere solo alcuni metodi HTTP**

``` ts
app.use(cors({
  origin: 'http://localhost:3000',
  methods: ['GET', 'POST']
}));
```

âœ… 5. **Permettere solo alcune intestazioni**

``` ts
app.use(cors({
  origin: 'http://localhost:3000',
  allowedHeaders: ['Content-Type', 'Authorization']
}));
```

âœ… 6. Permettere tutto (default)

``` ts
app.use(cors());
```
### ğŸ”¹ `app.use(morgan("tiny"));`

âœ… **Cos'Ã¨:**  
Aggiunge il middleware **Morgan**, un **logger HTTP**.

âœ… **A cosa serve:**  
Registra nella console ogni richiesta HTTP al server, ad esempio:

``` bash
GET /api/users 200 12ms
```

ğŸ› ï¸ `"tiny"` Ã¨ il formato piÃ¹ minimal. Esistono anche `"combined"`, `"dev"`, `"short"`, ecc.

### ğŸ”¹ `app.use(bodyParser.json());`

âœ… **Cos'Ã¨:**  
Permette di **parsing del corpo delle richieste JSON**.

âœ… **A cosa serve:**  
Traduce il JSON nel `req.body` delle richieste POST, PUT, ecc.  
Ad esempio:

``` json
{
  "name": "Alice"
}
```

diventa

``` ts
req.body.name
```

ğŸ” **Nota moderna:** oggi puoi anche usare `express.json()` al posto di `bodyParser.json()` (Ã¨ integrato in Express >= 4.16):

``` ts
app.use(express.json());
```

### ğŸ”¹ `app.use("/api", apiRouter);`

âœ… **Cos'Ã¨:**  
Usa un **router** separato per le rotte che iniziano con `/api`.

âœ… **A cosa serve:**  
Inoltra le richieste `/api/...` a un file/router definito separatamente, ad esempio:

``` ts 
// apiRouter.ts
router.get("/users", ...) // corrisponde a /api/users
```

ğŸ§± Questo aiuta a **organizzare meglio** il codice, separando le route API dal resto dellâ€™app.

### ğŸ”¹ `app.use(errorHandlers);`

âœ… **Cos'Ã¨:**  
Un middleware per la **gestione centralizzata degli errori**.

âœ… **A cosa serve:**  
Cattura e gestisce tutti gli errori non gestiti a monte, evitando che Express crashi.

ğŸ” Vedi la sezione errori dove ne parlo [qui](./02.errors_handling)

âš ï¸ Assicurati che `errorHandlers` sia **lâ€™ultimo `app.use()`** chiamato, cosÃ¬ cattura gli errori provenienti da tutte le route precedenti.

### routes.ts`

``` ts
import express from "express";

const router = express.Router();

export default router;
```

Qui semplicemente ti salvi le rotte per le tue api, adesso facciamo un esempio di aggiunta di una rotta:

``` ts
router.use("users", userRouter)
```

Che, come detto prima porterÃ  a /api/users